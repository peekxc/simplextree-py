{
  "hash": "276bc85319bc1395a0c4d75bcb946473",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nformat:\n  html:\n    code-fold: false\njupyter: python3\nexecute: \n  freeze: auto\n  enabled: true\ndraft: false\n---\n\n\n\n\n## Quick Start \n\nYou can construct a `SimplexTree` by supplying simplices. Any collection of integer-valued `Iterable`'s will do, e.g. a list of lists: \n\n::: {#8c6209ce .cell execution_count=2}\n``` {.python .cell-code lst-cap=\"The SimplexTree class provides light wrapper around the extension module\" code-summary=\"SimplexTree constructor\"}\nfrom simplextree import SimplexTree\nst = SimplexTree([[0,1,2], [0,1], [4,5]]) \nprint(st) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimplex Tree with (5, 4, 1) (0, 1, 2)-simplices\n```\n:::\n:::\n\n\nBatch insertion, removal, and membership queries are supported\n\n::: {#bc35b29c .cell execution_count=3}\n``` {.python .cell-code code-summary=\"Batch operations\"}\nst.insert([[1,4], [1,5], [6]])\nprint(st)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimplex Tree with (6, 6, 1) (0, 1, 2)-simplices\n```\n:::\n:::\n\n\n::: {#f3379209 .cell execution_count=4}\n``` {.python .cell-code}\nst.remove([[6]])\nprint(st)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimplex Tree with (5, 6, 1) (0, 1, 2)-simplices\n```\n:::\n:::\n\n\n::: {#43ba3fca .cell execution_count=5}\n``` {.python .cell-code}\nprint(st.find([[6], [0,1]]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[False  True]\n```\n:::\n:::\n\n\nCollections of simplices are returned as simple lists-of-tuples:\n\n::: {#74633651 .cell execution_count=6}\n``` {.python .cell-code code-summary=\"Complex collections\"}\nprint(st.simplices())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[(0,), (1,), (2,), (4,), (5,), (0, 1), (0, 2), (1, 2), (1, 4), (1, 5), (4, 5), (0, 1, 2)]\n```\n:::\n:::\n\n\nYou can restrict to specific dimensions by supplying the argument `p`:\n\n::: {#956de1ed .cell execution_count=7}\n``` {.python .cell-code}\nprint(st.simplices(p=1)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[(0, 1), (0, 2), (1, 2), (1, 4), (1, 5), (4, 5)]\n```\n:::\n:::\n\n\nFamiliar Pythonic [Collection semantics](https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes) are supported, including \\_\\_contains\\_\\_, \\_\\_iter\\_\\_ support, and \\_\\_len\\_\\_:\n\n::: {#8388f659 .cell execution_count=8}\n``` {.python .cell-code}\nprint([0,1,2] in st)\nprint([len(simplex) for simplex in st])\nprint(len(st))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n[1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3]\n12\n```\n:::\n:::\n\n\nThe cofaces of any simplex can be listed with `cofaces`:\n\n::: {#5dacaf87 .cell execution_count=9}\n``` {.python .cell-code}\nprint(\"Cofaces([1]): \" + str(st.cofaces([1])))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCofaces([1]): [(1,), (1, 2), (1, 4), (1, 5), (0, 1), (0, 1, 2)]\n```\n:::\n:::\n\n\nThe maximal simplices can be listed with `maximal`:\n\n::: {#6ed8f520 .cell execution_count=10}\n``` {.python .cell-code}\nprint(\"Maximal: \" + str(st.maximal()))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMaximal: [(0, 1, 2), (1, 4), (1, 5), (4, 5)]\n```\n:::\n:::\n\n\nBasic properties are also available as attributes \n\n::: {#51dab964 .cell execution_count=11}\n``` {.python .cell-code}\nst.n_simplices, st.dimension, st.vertices, st.connected_components\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n(array([5, 6, 1], dtype=uint64), 2, [0, 1, 2, 4, 5], [1, 1, 1, 1, 1])\n```\n:::\n:::\n\n\nInteroperability with numpy is provided whenever possible\n\n::: {#b7a9506c .cell execution_count=12}\n``` {.python .cell-code}\nimport numpy as np \nall(np.all(st.triangles == np.array(st.simplices(p=2)), axis=0))\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nTrue\n```\n:::\n:::\n\n\nOther complex-wide operations are supported, like $k$-expansions \n\n::: {#aba80097 .cell execution_count=13}\n``` {.python .cell-code}\nst.insert([[1,4]]) \nst.expand(2)       \nprint(st)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimplex Tree with (5, 6, 2) (0, 1, 2)-simplices\n```\n:::\n:::\n\n\nThe trie-structure can also be inspected on the python side with `print_tree`:\n\n::: {#81a9bceb .cell execution_count=14}\n``` {.python .cell-code}\nst.print_tree()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0 (h = 2): .( 1 2 )..( 2 )\n1 (h = 2): .( 2 4 5 )..( 5 )\n2 (h = 0): \n4 (h = 1): .( 5 )\n5 (h = 0): \n```\n:::\n:::\n\n\nAnother way to inspect the trie structure is to use a _traversal_, e.g. the depth-first manner (prefix-order):\n\n::: {#dfd4b2aa .cell execution_count=15}\n``` {.python .cell-code}\nst.traverse(\"dfs\", f=print)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(0,)\n(0, 1)\n(0, 1, 2)\n(0, 2)\n(1,)\n(1, 2)\n(1, 4)\n(1, 4, 5)\n(1, 5)\n(2,)\n(4,)\n(4, 5)\n(5,)\n```\n:::\n:::\n\n\nSeveral traversal orderings are provided, e.g. breadth-first (or level-order) could be used as well:\n\n::: {#1f15cd63 .cell execution_count=16}\n``` {.python .cell-code}\nst.traverse(\"bfs\", f=print)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(0,)\n(1,)\n(2,)\n(4,)\n(5,)\n(0, 1)\n(0, 2)\n(1, 2)\n(1, 4)\n(1, 5)\n(4, 5)\n(0, 1, 2)\n(1, 4, 5)\n```\n:::\n:::\n\n\nIn fact, most operations on the Simplex tree are actually _implemented_ using traversals. For example, you can traverse only the maximal faces like so: \n\n::: {#49572c79 .cell execution_count=17}\n``` {.python .cell-code}\nst.traverse(\"maximal\", f=print)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(0, 1, 2)\n(1, 4, 5)\n```\n:::\n:::\n\n\nYou can supply any `Callable` to `f` (the default is to print). For example, to extract the dimensions of the maximal simplices:\n\n::: {#5b01b558 .cell execution_count=18}\n``` {.python .cell-code}\nmaximal_dims = []\nst.traverse(\"maximal\", f=lambda s: maximal_dims.append(len(s)-1))\nprint(maximal_dims)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 2]\n```\n:::\n:::\n\n\nThe simplex type can be configured via the `s_type` attribute. \n\n::: {#62450974 .cell execution_count=19}\n``` {.python .cell-code}\nst.s_type = list\nprint(st.maximal())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[0, 1, 2], [1, 4, 5]]\n```\n:::\n:::\n\n\nThe default (and recommended) type is `tuple`. If the type is `Hashable`, simplex properties can be tracked easily external dictionary (a technique inspired by Boosts [property maps](https://www.boost.org/doc/libs/1_86_0/libs/property_map/doc/property_map.html)):\n\n::: {#5038c839 .cell execution_count=20}\n``` {.python .cell-code}\nst.s_type = tuple\ncolors = [\"red\", \"orange\", \"yellow\", \"purple\"]\nsimplex_colors = { s : colors[len(s) - 1] for s in st }\nprint(simplex_colors)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{(0,): 'red', (1,): 'red', (2,): 'red', (4,): 'red', (5,): 'red', (0, 1): 'orange', (0, 2): 'orange', (1, 2): 'orange', (1, 4): 'orange', (1, 5): 'orange', (4, 5): 'orange', (0, 1, 2): 'yellow', (1, 4, 5): 'yellow'}\n```\n:::\n:::\n\n\nOn the other hand, if you work a lot with numpy, you may want the default simplex type to be an array:\n\n::: {#f2c2c4da .cell execution_count=21}\n``` {.python .cell-code}\nst.s_type = np.array\nedges = np.array(st.simplices(p=1))\nprint(edges)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[0 1]\n [0 2]\n [1 2]\n [1 4]\n [1 5]\n [4 5]]\n```\n:::\n:::\n\n\n",
    "supporting": [
      "quickstart_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}