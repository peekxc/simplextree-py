[
  {
    "objectID": "reference/UnionFind.UnionFind.html",
    "href": "reference/UnionFind.UnionFind.html",
    "title": "UnionFind.UnionFind",
    "section": "",
    "text": "UnionFind.UnionFind\nUnionFind.UnionFind(n)\nUnion Find data structure"
  },
  {
    "objectID": "reference/SimplexTree.SimplexTree.html",
    "href": "reference/SimplexTree.SimplexTree.html",
    "title": "SimplexTree.SimplexTree",
    "section": "",
    "text": "SimplexTree.SimplexTree(self, simplices=None)\nSimplexTree provides lightweight wrapper around a Simplex Tree data structure: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex. This class exposes a native extension module wrapping a simplex tree implemented with modern C++.\nThe Simplex Tree was originally introduced in the paper &gt; Boissonnat, Jean-Daniel, and Clément Maria. “The simplex tree: An efficient data structure for general simplicial complexes.” Algorithmica 70.3 (2014): 406-427.\nAttributes: n_simplices (ndarray): number of simplices dimension (int): maximal dimension of the complex id_policy (str): policy for generating new vertex ids\nAttributes: Properties: vertices (ndarray): vertices of the complex\n\n\n\n\n\nName\nDescription\n\n\n\n\nadjacent\nChecks for adjacencies between simplices.\n\n\ncard\nReturns the cardinality of various skeleta of the complex.\n\n\ncoface_roots\nReturns the simplex ‘roots’ of a given simplex whose subtrees generate its cofaces.\n\n\ncofaces\nReturns the p-cofaces of a given simplex.\n\n\ncollapse\nPerforms an elementary collapse on two given simplices.\n\n\ndegree\nComputes the degree of select vertices in the trie.\n\n\nexpand\nPerforms a k-expansion of the complex.\n\n\nfaces\nWrapper for simplices function.\n\n\nfind\nFinds whether simplices exist in Simplex Tree.\n\n\ninsert\nInserts simplices into the Simplex Tree.\n\n\nlink\nReturns all simplices in the link of a given simplex.\n\n\nmaximal\nReturns the maximal simplices in the complex.\n\n\nremove\nRemoves simplices into the Simplex Tree.\n\n\nsimplices\nReturns the p-simplices in the complex.\n\n\nskeleton\nReturns the simplices in the p-skeleton of the complex.\n\n\ntraverse\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered.\n\n\nvertex_collapse\nMaps a pair of vertices into a single vertex.\n\n\n\n\n\nSimplexTree.SimplexTree.adjacent(self, simplices)\nChecks for adjacencies between simplices.\n\n\n\nSimplexTree.SimplexTree.card(self, p=None)\nReturns the cardinality of various skeleta of the complex.\n\n\n\nSimplexTree.SimplexTree.coface_roots(self, sigma=\\[\\])\nReturns the simplex ‘roots’ of a given simplex whose subtrees generate its cofaces.\n\n\n\nSimplexTree.SimplexTree.cofaces(self, sigma=\\[\\])\nReturns the p-cofaces of a given simplex.\nParameters: p : coface dimension to restrict to sigma : the simplex to obtain cofaces of\nReturns: list: the p-cofaces of sigma\n\n\n\nSimplexTree.SimplexTree.collapse(self, tau, sigma)\nPerforms an elementary collapse on two given simplices.\nChecks whether its possible to collapse \\sigma through \\tau, and if so, both simplices are removed. A simplex \\sigma is said to be collapsible through one of its faces \\tau if \\sigma is the only coface of \\tau (excluding \\tau itself).\nParameters: sigma : maximal simplex to collapse tau : face of sigma to collapse\nReturns: bool: whether the pair was collapsed\nExamples:\n    from splex import SimplexTree \n    st = SimplexTree([[0,1,2]])\n    print(st)\n\n    st.collapse([1,2], [0,1,2])\n\n    print(st)\n\n\n\nSimplexTree.SimplexTree.degree(self, vertices=None)\nComputes the degree of select vertices in the trie.\nParameters: vertices (ArrayLike): Retrieves vertex degrees If no vertices are specified, all degrees are computed. Non-existing vertices by default have degree 0.\nReturns: list: degree of each vertex id given in ‘vertices’\n\n\n\nSimplexTree.SimplexTree.expand(self, k)\nPerforms a k-expansion of the complex.\nThis function is particularly useful for expanding clique complexes beyond their 1-skeleton.\nParameters: k : maximum dimension to expand to.\nExamples:\n    from simplextree import SimplexTree \n    from itertools import combinations \n    st = SimplexTree(combinations(range(8), 2))\n    print(st)\n    \n    st.expand(k=2)\n    print(st)\n\n\n\nSimplexTree.SimplexTree.faces(self, p=None, sigma=\\[\\], **kwargs)\nWrapper for simplices function.\n\n\n\nSimplexTree.SimplexTree.find(self, simplices)\nFinds whether simplices exist in Simplex Tree.\nParameters: simplices: Iterable of simplices to insert (each of which are SimplexLike)\nReturns: found (ndarray) : boolean array indicating whether each simplex was found in the complex\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then the p-simplex to find is given by each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then searched for in the tree. \n\n\n\n\n\nSimplexTree.SimplexTree.insert(self, simplices)\nInserts simplices into the Simplex Tree.\nBy definition, inserting a simplex also inserts all of its faces. If the simplex already exists in the complex, the tree is not modified.\nParameters: simplices: Iterable of simplices to insert (each of which are SimplexLike)\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is inserted along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then inserted into the tree. \n\n\n\n\n\nSimplexTree.SimplexTree.link(self, sigma=\\[\\])\nReturns all simplices in the link of a given simplex.\n\n\n\nSimplexTree.SimplexTree.maximal(self)\nReturns the maximal simplices in the complex.\n\n\n\nSimplexTree.SimplexTree.remove(self, simplices)\nRemoves simplices into the Simplex Tree.\nBy definition, removing a face also removes all of its cofaces. If the simplex does not exist in the complex, the tree is not modified.\nParameters: simplices: Iterable of simplices to insert (each of which are SimplexLike).\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is removed along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then removed from the tree. \n\n\nExamples: st = SimplexTree([range(3)]) print(st) st.remove([[0,1]]) print(st)\n\n\n\nSimplexTree.SimplexTree.simplices(self, p=None)\nReturns the p-simplices in the complex.\n\n\n\nSimplexTree.SimplexTree.skeleton(self, p=None, sigma=\\[\\])\nReturns the simplices in the p-skeleton of the complex.\n\n\n\nSimplexTree.SimplexTree.traverse(self, order='preorder', f=print, sigma=\\[\\], p=0)\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered.\nSupported traversals: - breadth-first / level order (“bfs”, “levelorder”) - depth-first / prefix (“dfs”, “preorder”) - faces - cofaces - coface roots (“coface_roots”) - p-skeleton - p-simplices - maximal simplices (“maximal”) - link To select one of these options, set order to one of [“bfs”, “levelorder”, “dfs”, “preorder”]\nParameters: order: the type of traversal of the simplex tree to execute. f: a function to evaluate on every simplex in the traversal. Defaults to print. sigma: simplex to start the traversal at, where applicable. Defaults to the root node (empty set). p: dimension of simplices to restrict to, where applicable. Defaults to 0.\n\n\n\nSimplexTree.SimplexTree.vertex_collapse(self, u, v, w)\nMaps a pair of vertices into a single vertex.\nParameters: u (int): the first vertex in the free pair. v (int): the second vertex in the free pair. w (int): the target vertex to collapse to."
  },
  {
    "objectID": "reference/SimplexTree.SimplexTree.html#methods",
    "href": "reference/SimplexTree.SimplexTree.html#methods",
    "title": "SimplexTree.SimplexTree",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nadjacent\nChecks for adjacencies between simplices.\n\n\ncard\nReturns the cardinality of various skeleta of the complex.\n\n\ncoface_roots\nReturns the simplex ‘roots’ of a given simplex whose subtrees generate its cofaces.\n\n\ncofaces\nReturns the p-cofaces of a given simplex.\n\n\ncollapse\nPerforms an elementary collapse on two given simplices.\n\n\ndegree\nComputes the degree of select vertices in the trie.\n\n\nexpand\nPerforms a k-expansion of the complex.\n\n\nfaces\nWrapper for simplices function.\n\n\nfind\nFinds whether simplices exist in Simplex Tree.\n\n\ninsert\nInserts simplices into the Simplex Tree.\n\n\nlink\nReturns all simplices in the link of a given simplex.\n\n\nmaximal\nReturns the maximal simplices in the complex.\n\n\nremove\nRemoves simplices into the Simplex Tree.\n\n\nsimplices\nReturns the p-simplices in the complex.\n\n\nskeleton\nReturns the simplices in the p-skeleton of the complex.\n\n\ntraverse\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered.\n\n\nvertex_collapse\nMaps a pair of vertices into a single vertex.\n\n\n\n\n\nSimplexTree.SimplexTree.adjacent(self, simplices)\nChecks for adjacencies between simplices.\n\n\n\nSimplexTree.SimplexTree.card(self, p=None)\nReturns the cardinality of various skeleta of the complex.\n\n\n\nSimplexTree.SimplexTree.coface_roots(self, sigma=\\[\\])\nReturns the simplex ‘roots’ of a given simplex whose subtrees generate its cofaces.\n\n\n\nSimplexTree.SimplexTree.cofaces(self, sigma=\\[\\])\nReturns the p-cofaces of a given simplex.\nParameters: p : coface dimension to restrict to sigma : the simplex to obtain cofaces of\nReturns: list: the p-cofaces of sigma\n\n\n\nSimplexTree.SimplexTree.collapse(self, tau, sigma)\nPerforms an elementary collapse on two given simplices.\nChecks whether its possible to collapse \\sigma through \\tau, and if so, both simplices are removed. A simplex \\sigma is said to be collapsible through one of its faces \\tau if \\sigma is the only coface of \\tau (excluding \\tau itself).\nParameters: sigma : maximal simplex to collapse tau : face of sigma to collapse\nReturns: bool: whether the pair was collapsed\nExamples:\n    from splex import SimplexTree \n    st = SimplexTree([[0,1,2]])\n    print(st)\n\n    st.collapse([1,2], [0,1,2])\n\n    print(st)\n\n\n\nSimplexTree.SimplexTree.degree(self, vertices=None)\nComputes the degree of select vertices in the trie.\nParameters: vertices (ArrayLike): Retrieves vertex degrees If no vertices are specified, all degrees are computed. Non-existing vertices by default have degree 0.\nReturns: list: degree of each vertex id given in ‘vertices’\n\n\n\nSimplexTree.SimplexTree.expand(self, k)\nPerforms a k-expansion of the complex.\nThis function is particularly useful for expanding clique complexes beyond their 1-skeleton.\nParameters: k : maximum dimension to expand to.\nExamples:\n    from simplextree import SimplexTree \n    from itertools import combinations \n    st = SimplexTree(combinations(range(8), 2))\n    print(st)\n    \n    st.expand(k=2)\n    print(st)\n\n\n\nSimplexTree.SimplexTree.faces(self, p=None, sigma=\\[\\], **kwargs)\nWrapper for simplices function.\n\n\n\nSimplexTree.SimplexTree.find(self, simplices)\nFinds whether simplices exist in Simplex Tree.\nParameters: simplices: Iterable of simplices to insert (each of which are SimplexLike)\nReturns: found (ndarray) : boolean array indicating whether each simplex was found in the complex\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then the p-simplex to find is given by each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then searched for in the tree. \n\n\n\n\n\nSimplexTree.SimplexTree.insert(self, simplices)\nInserts simplices into the Simplex Tree.\nBy definition, inserting a simplex also inserts all of its faces. If the simplex already exists in the complex, the tree is not modified.\nParameters: simplices: Iterable of simplices to insert (each of which are SimplexLike)\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is inserted along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then inserted into the tree. \n\n\n\n\n\nSimplexTree.SimplexTree.link(self, sigma=\\[\\])\nReturns all simplices in the link of a given simplex.\n\n\n\nSimplexTree.SimplexTree.maximal(self)\nReturns the maximal simplices in the complex.\n\n\n\nSimplexTree.SimplexTree.remove(self, simplices)\nRemoves simplices into the Simplex Tree.\nBy definition, removing a face also removes all of its cofaces. If the simplex does not exist in the complex, the tree is not modified.\nParameters: simplices: Iterable of simplices to insert (each of which are SimplexLike).\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is removed along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then removed from the tree. \n\n\nExamples: st = SimplexTree([range(3)]) print(st) st.remove([[0,1]]) print(st)\n\n\n\nSimplexTree.SimplexTree.simplices(self, p=None)\nReturns the p-simplices in the complex.\n\n\n\nSimplexTree.SimplexTree.skeleton(self, p=None, sigma=\\[\\])\nReturns the simplices in the p-skeleton of the complex.\n\n\n\nSimplexTree.SimplexTree.traverse(self, order='preorder', f=print, sigma=\\[\\], p=0)\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered.\nSupported traversals: - breadth-first / level order (“bfs”, “levelorder”) - depth-first / prefix (“dfs”, “preorder”) - faces - cofaces - coface roots (“coface_roots”) - p-skeleton - p-simplices - maximal simplices (“maximal”) - link To select one of these options, set order to one of [“bfs”, “levelorder”, “dfs”, “preorder”]\nParameters: order: the type of traversal of the simplex tree to execute. f: a function to evaluate on every simplex in the traversal. Defaults to print. sigma: simplex to start the traversal at, where applicable. Defaults to the root node (empty set). p: dimension of simplices to restrict to, where applicable. Defaults to 0.\n\n\n\nSimplexTree.SimplexTree.vertex_collapse(self, u, v, w)\nMaps a pair of vertices into a single vertex.\nParameters: u (int): the first vertex in the free pair. v (int): the second vertex in the free pair. w (int): the target vertex to collapse to."
  },
  {
    "objectID": "pages/reference/index.html",
    "href": "pages/reference/index.html",
    "title": "API Reference",
    "section": "",
    "text": "SimplexTree.SimplexTree\nSimplexTree provides lightweight wrapper around a Simplex Tree data structure: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex.\n\n\n\n\n\n\n\n\n\nUnionFind.UnionFind\nUnion Find data structure"
  },
  {
    "objectID": "pages/reference/index.html#simplex-tree",
    "href": "pages/reference/index.html#simplex-tree",
    "title": "API Reference",
    "section": "",
    "text": "SimplexTree.SimplexTree\nSimplexTree provides lightweight wrapper around a Simplex Tree data structure: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex."
  },
  {
    "objectID": "pages/reference/index.html#union-find",
    "href": "pages/reference/index.html#union-find",
    "title": "API Reference",
    "section": "",
    "text": "UnionFind.UnionFind\nUnion Find data structure"
  },
  {
    "objectID": "pages/overview.html",
    "href": "pages/overview.html",
    "title": "Overview of the simplextree package",
    "section": "",
    "text": "A simplicial complex S is a pair S = (V, \\Sigma) where V is a vertex set and \\Sigma a collection of simplices s \\in \\Sigma satisfying:\n\nIf v \\in V, then v \\in S\nIf \\tau \\subset \\sigma and \\sigma \\in S, then \\tau \\in S\n\nA simplicial complex is a natural generalization of a graph—any graph can also be represented by a simplicial complex (though the converse is not true!).\nLike graphs, there are many ways to represent simplicial complexes in memory. One such way is to use a Simplex Tree: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex. Here’s a picture of a simplicial 3-complex (left) and its corresponding Simplex Tree (right):\n\n\n\nPicture taken from Boissonnat et al: “The simplex tree: An efficient data structure for general simplicial complexes”\n\n\nTo construct the complex above with a simplextree package, simply give the maximal simplices:\n\nfrom simplextree import SimplexTree\nst = SimplexTree([[1,2,3],[2,3,4,5],[6,7,9],[7,8],[10]]) # complex form the picture\nprint(st)\n\nSimplex Tree with (10, 12, 6, 1) (0, 1, 2, 3)-simplices\n\n\nTo look at the tree structure, use print_tree (see also: print_cousins)\n\nst.print_tree()\n\n1 (h = 2): .( 2 3 )..( 3 )\n2 (h = 3): .( 3 4 5 )..( 4 5 5 )...( 5 )\n3 (h = 2): .( 4 5 )..( 5 )\n4 (h = 1): .( 5 )\n5 (h = 0): \n6 (h = 2): .( 7 9 )..( 9 )\n7 (h = 1): .( 8 9 )\n8 (h = 0): \n9 (h = 0): \n10 (h = 0): \n\n\nTo maintain fast coface lookup and enumeration, extra links are added between nodes at the same level, which are shown by the dash-dotted lines in the figure above (only for the nodes with the label 5). To view these links with the SimplexTree class, use print_cousins():\n\nst.print_cousins()\n\n(last=2, depth=2): { 1 2 } \n(last=3, depth=2): { 1 3 } { 2 3 } \n(last=4, depth=2): { 2 4 } { 3 4 } \n(last=5, depth=2): { 2 5 } { 3 5 } { 4 5 } \n(last=7, depth=2): { 6 7 } \n(last=8, depth=2): { 7 8 } \n(last=9, depth=2): { 6 9 } { 7 9 } \n(last=3, depth=3): { 1 2 3 } \n(last=4, depth=3): { 2 3 4 } \n(last=5, depth=3): { 2 3 5 } { 2 4 5 } { 3 4 5 } \n(last=9, depth=3): { 6 7 9 } \n(last=5, depth=4): { 2 3 4 5 }"
  },
  {
    "objectID": "pages/index.html",
    "href": "pages/index.html",
    "title": "simplextree",
    "section": "",
    "text": "simplextree is an Python package that simplifies computation for general simplicial complexes of any dimension by providing pybind11 bindings to a Simplex Tree data structure implemented in modern C++17.\nA Simplex Tree is an ordered, trie-like structure whose nodes are in bijection with the faces of the complex. Here’s a picture of a simplicial 3-complex (left) and its corresponding Simplex Tree (right):\nThe Simplex Tree was originally introduced in the following paper:\nThe SimplexTree class exported by the package includes support for many tree operations, e.g. insertions, removals, expansions, collapses, star/link enumerations, and other traversals."
  },
  {
    "objectID": "pages/index.html#install",
    "href": "pages/index.html#install",
    "title": "simplextree",
    "section": "Install",
    "text": "Install\nThe easiest way to install the package is via the platform-specific wheels on pypi.\npython -m pip install simplextree \nYou can also pip install the package manually by downloading the appropriate wheel (or sdist) from the releases.\nFor installation instructions for developers looking to extend the package, see Building & Developing."
  },
  {
    "objectID": "pages/index.html#building-developing",
    "href": "pages/index.html#building-developing",
    "title": "simplextree",
    "section": "Building & Developing",
    "text": "Building & Developing\nIf you would like to build the package yourself for development reasons, a typical workflow is to install the build-time dependencies first:\npython -m pip install meson-python ninja pybind11 numpy\nThen, build and install the package in editable mode (see also meson-python notes), optionally without build isolation for speed:\npython -m pip install --no-build-isolation --editable .\nUnit testing is handled with pytest. See the gh-workflows for platform-specific configuration."
  },
  {
    "objectID": "pages/index.html#native-extensions",
    "href": "pages/index.html#native-extensions",
    "title": "simplextree",
    "section": "Native Extensions",
    "text": "Native Extensions\nThe underlying C++ library is header-only and may be included as a dependency by extension modules in other Python packages.\nThus, to modify or extending the complex in C++, it is sufficient to add the package as a build-time dependency and append the include directory to the compilation target."
  },
  {
    "objectID": "pages/reference/SimplexTree.SimplexTree.html",
    "href": "pages/reference/SimplexTree.SimplexTree.html",
    "title": "SimplexTree.SimplexTree",
    "section": "",
    "text": "SimplexTree.SimplexTree(self, simplices=None)\nSimplexTree provides lightweight wrapper around a Simplex Tree data structure: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex. This class exposes a native extension module wrapping a simplex tree implemented with modern C++.\nThe Simplex Tree was originally introduced in the paper &gt; Boissonnat, Jean-Daniel, and Clément Maria. “The simplex tree: An efficient data structure for general simplicial complexes.” Algorithmica 70.3 (2014): 406-427.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nn_simplices\nndarray\nnumber of simplices\n\n\ndimension\nint\nmaximal dimension of the complex\n\n\nid_policy\nstr\npolicy for generating new vertex ids\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nvertices\nndarray\nvertices of the complex\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadjacent\nChecks for adjacencies between simplices.\n\n\ncard\nReturns the cardinality of various skeleta of the complex.\n\n\ncoface_roots\nReturns the simplex ‘roots’ of a given simplex whose subtrees generate its cofaces.\n\n\ncofaces\nReturns the p-cofaces of a given simplex.\n\n\ncollapse\nPerforms an elementary collapse on two given simplices.\n\n\ndegree\nComputes the degree of select vertices in the trie.\n\n\nexpand\nPerforms a k-expansion of the complex.\n\n\nfaces\nWrapper for simplices function.\n\n\nfind\nFinds whether simplices exist in Simplex Tree.\n\n\ninsert\nInserts simplices into the Simplex Tree.\n\n\nlink\nReturns all simplices in the link of a given simplex.\n\n\nmaximal\nReturns the maximal simplices in the complex.\n\n\nremove\nRemoves simplices into the Simplex Tree.\n\n\nsimplices\nReturns the p-simplices in the complex.\n\n\nskeleton\nReturns the simplices in the p-skeleton of the complex.\n\n\ntraverse\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered.\n\n\nvertex_collapse\nMaps a pair of vertices into a single vertex.\n\n\n\n\n\nSimplexTree.SimplexTree.adjacent(self, simplices)\nChecks for adjacencies between simplices.\n\n\n\nSimplexTree.SimplexTree.card(self, p=None)\nReturns the cardinality of various skeleta of the complex.\n\n\n\nSimplexTree.SimplexTree.coface_roots(self, sigma=\\[\\])\nReturns the simplex ‘roots’ of a given simplex whose subtrees generate its cofaces.\n\n\n\nSimplexTree.SimplexTree.cofaces(self, sigma=\\[\\])\nReturns the p-cofaces of a given simplex.\n\n\np : required\n\ncoface dimension to restrict to\n\nsigma : optional (default=[])\n\nthe simplex to obtain cofaces of\n\n\n\n\nlist :  list[Collection], \n\nthe p-cofaces of sigma\n\n\n\n\n\nSimplexTree.SimplexTree.collapse(self, tau, sigma)\nPerforms an elementary collapse on two given simplices.\nChecks whether its possible to collapse \\sigma through \\tau, and if so, both simplices are removed. A simplex \\sigma is said to be collapsible through one of its faces \\tau if \\sigma is the only coface of \\tau (excluding \\tau itself).\n\n\nsigma : required\n\nmaximal simplex to collapse\n\ntau : required\n\nface of sigma to collapse\n\n\n\n\nbool : None,\n\nwhether the pair was collapsed\n\n\n\n\nfrom splex import SimplexTree st = SimplexTree([[0,1,2]]) print(st)\nst.collapse([1,2], [0,1,2])\nprint(st)\n\n\n\n\nSimplexTree.SimplexTree.degree(self, vertices=None)\nComputes the degree of select vertices in the trie.\n\n\nvertices :  numpy.typing.ArrayLike, optional (default=None)\n\nRetrieves vertex degrees If no vertices are specified, all degrees are computed. Non-existing vertices by default have degree 0.\n\n\n\n\nlist :  Union[numpy.typing.ArrayLike, int], \n\ndegree of each vertex id given in ‘vertices’\n\n\n\n\n\nSimplexTree.SimplexTree.expand(self, k)\nPerforms a k-expansion of the complex.\nThis function is particularly useful for expanding clique complexes beyond their 1-skeleton.\n\n\nk : required\n\nmaximum dimension to expand to.\n\n\n\n\nfrom simplextree import SimplexTree from itertools import combinations st = SimplexTree(combinations(range(8), 2)) print(st)\nst.expand(k=2) print(st)\n\n\n\n\nSimplexTree.SimplexTree.faces(self, p=None, sigma=\\[\\], **kwargs)\nWrapper for simplices function.\n\n\n\nSimplexTree.SimplexTree.find(self, simplices)\nFinds whether simplices exist in Simplex Tree.\n\n\nsimplices :  Iterable[Collection], required\n\nIterable of simplices to insert (each of which are SimplexLike)\n\n\n\n\n**** :\n\nfound (ndarray) : boolean array indicating whether each simplex was found in the complex\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then the p-simplex to find is given by each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then searched for in the tree. \n\n\n\n\n\n\nSimplexTree.SimplexTree.insert(self, simplices)\nInserts simplices into the Simplex Tree.\nBy definition, inserting a simplex also inserts all of its faces. If the simplex already exists in the complex, the tree is not modified.\n\n\nsimplices :  Iterable[Collection], required\n\nIterable of simplices to insert (each of which are SimplexLike)\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is inserted along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then inserted into the tree. \n\n\n\n\n\n\nSimplexTree.SimplexTree.link(self, sigma=\\[\\])\nReturns all simplices in the link of a given simplex.\n\n\n\nSimplexTree.SimplexTree.maximal(self)\nReturns the maximal simplices in the complex.\n\n\n\nSimplexTree.SimplexTree.remove(self, simplices)\nRemoves simplices into the Simplex Tree.\nBy definition, removing a face also removes all of its cofaces. If the simplex does not exist in the complex, the tree is not modified.\n\n\nsimplices :  Iterable[Collection], required\n\nIterable of simplices to insert (each of which are SimplexLike).\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is removed along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then removed from the tree. \n\n\n\n\n\nst = SimplexTree([range(3)]) print(st) st.remove([[0,1]]) print(st)\n\n\n\n\nSimplexTree.SimplexTree.simplices(self, p=None)\nReturns the p-simplices in the complex.\n\n\n\nSimplexTree.SimplexTree.skeleton(self, p=None, sigma=\\[\\])\nReturns the simplices in the p-skeleton of the complex.\n\n\n\nSimplexTree.SimplexTree.traverse(self, order='preorder', f=print, sigma=\\[\\], p=0)\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered.\n\n\nUNHANDLED ADMONITION\nTo select one of these options, set order to one of [“bfs”, “levelorder”, “dfs”, “preorder”]\n\n\n\norder :  str, optional (default=‘preorder’)\n\nthe type of traversal of the simplex tree to execute.\n\nf :  Callable, optional (default=print)\n\na function to evaluate on every simplex in the traversal. Defaults to print.\n\nsigma :  Collection, optional (default=[])\n\nsimplex to start the traversal at, where applicable. Defaults to the root node (empty set).\n\np :  int, optional (default=0)\n\ndimension of simplices to restrict to, where applicable. Defaults to 0.\n\n\n\n\n\nSimplexTree.SimplexTree.vertex_collapse(self, u, v, w)\nMaps a pair of vertices into a single vertex.\n\n\nu :  int, required\n\nthe first vertex in the free pair.\n\nv :  int, required\n\nthe second vertex in the free pair.\n\nw :  int, required\n\nthe target vertex to collapse to."
  },
  {
    "objectID": "pages/reference/SimplexTree.SimplexTree.html#attributes",
    "href": "pages/reference/SimplexTree.SimplexTree.html#attributes",
    "title": "SimplexTree.SimplexTree",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nn_simplices\nndarray\nnumber of simplices\n\n\ndimension\nint\nmaximal dimension of the complex\n\n\nid_policy\nstr\npolicy for generating new vertex ids"
  },
  {
    "objectID": "pages/reference/SimplexTree.SimplexTree.html#properties",
    "href": "pages/reference/SimplexTree.SimplexTree.html#properties",
    "title": "SimplexTree.SimplexTree",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nvertices\nndarray\nvertices of the complex"
  },
  {
    "objectID": "pages/reference/SimplexTree.SimplexTree.html#methods",
    "href": "pages/reference/SimplexTree.SimplexTree.html#methods",
    "title": "SimplexTree.SimplexTree",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nadjacent\nChecks for adjacencies between simplices.\n\n\ncard\nReturns the cardinality of various skeleta of the complex.\n\n\ncoface_roots\nReturns the simplex ‘roots’ of a given simplex whose subtrees generate its cofaces.\n\n\ncofaces\nReturns the p-cofaces of a given simplex.\n\n\ncollapse\nPerforms an elementary collapse on two given simplices.\n\n\ndegree\nComputes the degree of select vertices in the trie.\n\n\nexpand\nPerforms a k-expansion of the complex.\n\n\nfaces\nWrapper for simplices function.\n\n\nfind\nFinds whether simplices exist in Simplex Tree.\n\n\ninsert\nInserts simplices into the Simplex Tree.\n\n\nlink\nReturns all simplices in the link of a given simplex.\n\n\nmaximal\nReturns the maximal simplices in the complex.\n\n\nremove\nRemoves simplices into the Simplex Tree.\n\n\nsimplices\nReturns the p-simplices in the complex.\n\n\nskeleton\nReturns the simplices in the p-skeleton of the complex.\n\n\ntraverse\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered.\n\n\nvertex_collapse\nMaps a pair of vertices into a single vertex.\n\n\n\n\n\nSimplexTree.SimplexTree.adjacent(self, simplices)\nChecks for adjacencies between simplices.\n\n\n\nSimplexTree.SimplexTree.card(self, p=None)\nReturns the cardinality of various skeleta of the complex.\n\n\n\nSimplexTree.SimplexTree.coface_roots(self, sigma=\\[\\])\nReturns the simplex ‘roots’ of a given simplex whose subtrees generate its cofaces.\n\n\n\nSimplexTree.SimplexTree.cofaces(self, sigma=\\[\\])\nReturns the p-cofaces of a given simplex.\n\n\np : required\n\ncoface dimension to restrict to\n\nsigma : optional (default=[])\n\nthe simplex to obtain cofaces of\n\n\n\n\nlist :  list[Collection], \n\nthe p-cofaces of sigma\n\n\n\n\n\nSimplexTree.SimplexTree.collapse(self, tau, sigma)\nPerforms an elementary collapse on two given simplices.\nChecks whether its possible to collapse \\sigma through \\tau, and if so, both simplices are removed. A simplex \\sigma is said to be collapsible through one of its faces \\tau if \\sigma is the only coface of \\tau (excluding \\tau itself).\n\n\nsigma : required\n\nmaximal simplex to collapse\n\ntau : required\n\nface of sigma to collapse\n\n\n\n\nbool : None,\n\nwhether the pair was collapsed\n\n\n\n\nfrom splex import SimplexTree st = SimplexTree([[0,1,2]]) print(st)\nst.collapse([1,2], [0,1,2])\nprint(st)\n\n\n\n\nSimplexTree.SimplexTree.degree(self, vertices=None)\nComputes the degree of select vertices in the trie.\n\n\nvertices :  numpy.typing.ArrayLike, optional (default=None)\n\nRetrieves vertex degrees If no vertices are specified, all degrees are computed. Non-existing vertices by default have degree 0.\n\n\n\n\nlist :  Union[numpy.typing.ArrayLike, int], \n\ndegree of each vertex id given in ‘vertices’\n\n\n\n\n\nSimplexTree.SimplexTree.expand(self, k)\nPerforms a k-expansion of the complex.\nThis function is particularly useful for expanding clique complexes beyond their 1-skeleton.\n\n\nk : required\n\nmaximum dimension to expand to.\n\n\n\n\nfrom simplextree import SimplexTree from itertools import combinations st = SimplexTree(combinations(range(8), 2)) print(st)\nst.expand(k=2) print(st)\n\n\n\n\nSimplexTree.SimplexTree.faces(self, p=None, sigma=\\[\\], **kwargs)\nWrapper for simplices function.\n\n\n\nSimplexTree.SimplexTree.find(self, simplices)\nFinds whether simplices exist in Simplex Tree.\n\n\nsimplices :  Iterable[Collection], required\n\nIterable of simplices to insert (each of which are SimplexLike)\n\n\n\n\n**** :\n\nfound (ndarray) : boolean array indicating whether each simplex was found in the complex\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then the p-simplex to find is given by each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then searched for in the tree. \n\n\n\n\n\n\nSimplexTree.SimplexTree.insert(self, simplices)\nInserts simplices into the Simplex Tree.\nBy definition, inserting a simplex also inserts all of its faces. If the simplex already exists in the complex, the tree is not modified.\n\n\nsimplices :  Iterable[Collection], required\n\nIterable of simplices to insert (each of which are SimplexLike)\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is inserted along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then inserted into the tree. \n\n\n\n\n\n\nSimplexTree.SimplexTree.link(self, sigma=\\[\\])\nReturns all simplices in the link of a given simplex.\n\n\n\nSimplexTree.SimplexTree.maximal(self)\nReturns the maximal simplices in the complex.\n\n\n\nSimplexTree.SimplexTree.remove(self, simplices)\nRemoves simplices into the Simplex Tree.\nBy definition, removing a face also removes all of its cofaces. If the simplex does not exist in the complex, the tree is not modified.\n\n\nsimplices :  Iterable[Collection], required\n\nIterable of simplices to insert (each of which are SimplexLike).\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is removed along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then removed from the tree. \n\n\n\n\n\nst = SimplexTree([range(3)]) print(st) st.remove([[0,1]]) print(st)\n\n\n\n\nSimplexTree.SimplexTree.simplices(self, p=None)\nReturns the p-simplices in the complex.\n\n\n\nSimplexTree.SimplexTree.skeleton(self, p=None, sigma=\\[\\])\nReturns the simplices in the p-skeleton of the complex.\n\n\n\nSimplexTree.SimplexTree.traverse(self, order='preorder', f=print, sigma=\\[\\], p=0)\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered.\n\n\nUNHANDLED ADMONITION\nTo select one of these options, set order to one of [“bfs”, “levelorder”, “dfs”, “preorder”]\n\n\n\norder :  str, optional (default=‘preorder’)\n\nthe type of traversal of the simplex tree to execute.\n\nf :  Callable, optional (default=print)\n\na function to evaluate on every simplex in the traversal. Defaults to print.\n\nsigma :  Collection, optional (default=[])\n\nsimplex to start the traversal at, where applicable. Defaults to the root node (empty set).\n\np :  int, optional (default=0)\n\ndimension of simplices to restrict to, where applicable. Defaults to 0.\n\n\n\n\n\nSimplexTree.SimplexTree.vertex_collapse(self, u, v, w)\nMaps a pair of vertices into a single vertex.\n\n\nu :  int, required\n\nthe first vertex in the free pair.\n\nv :  int, required\n\nthe second vertex in the free pair.\n\nw :  int, required\n\nthe target vertex to collapse to."
  },
  {
    "objectID": "pages/reference/UnionFind.UnionFind.html",
    "href": "pages/reference/UnionFind.UnionFind.html",
    "title": "UnionFind.UnionFind",
    "section": "",
    "text": "UnionFind.UnionFind\nUnionFind.UnionFind(n)\nUnion Find data structure"
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "API Reference",
    "section": "",
    "text": "SimplexTree.SimplexTree\nSimplexTree provides lightweight wrapper around a Simplex Tree data structure: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex.\n\n\n\n\n\n\n\n\n\nUnionFind.UnionFind\nUnion Find data structure"
  },
  {
    "objectID": "reference/index.html#simplex-tree",
    "href": "reference/index.html#simplex-tree",
    "title": "API Reference",
    "section": "",
    "text": "SimplexTree.SimplexTree\nSimplexTree provides lightweight wrapper around a Simplex Tree data structure: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex."
  },
  {
    "objectID": "reference/index.html#union-find",
    "href": "reference/index.html#union-find",
    "title": "API Reference",
    "section": "",
    "text": "UnionFind.UnionFind\nUnion Find data structure"
  }
]