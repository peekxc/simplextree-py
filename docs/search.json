[
  {
    "objectID": "reference/VERSION.html",
    "href": "reference/VERSION.html",
    "title": "VERSION",
    "section": "",
    "text": "VERSION\nVERSION\nstr(object=’’) -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str\nCreate a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to ‘strict’."
  },
  {
    "objectID": "reference/SimplexTree.html",
    "href": "reference/SimplexTree.html",
    "title": "SimplexTree",
    "section": "",
    "text": "SimplexTree\n\n\n\n\n\nName\nDescription\n\n\n\n\nSimplexTree\nSimplexTree provides lightweight wrapper around a Simplex Tree data structure: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex.\n\n\n\n\n\nSimplexTree.SimplexTree(self, simplices=None)\nSimplexTree provides lightweight wrapper around a Simplex Tree data structure: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex. This class exposes a native extension module wrapping a simplex tree implemented with modern C++.\nThe Simplex Tree was originally introduced in the paper &gt; Boissonnat, Jean-Daniel, and Clément Maria. “The simplex tree: An efficient data structure for general simplicial complexes.” Algorithmica 70.3 (2014): 406-427.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nn_simplices\nndarray\nnumber of simplices\n\n\ndimension\nint\nmaximal dimension of the complex\n\n\nid_policy\nstr\npolicy for generating new vertex ids\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nvertices\nndarray\nvertices of the complex\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadjacent\nChecks for adjacencies between simplices.\n\n\ncard\nReturns the cardinality of various skeleta of the complex.\n\n\ncoface_roots\nReturns the simplex ‘roots’ of a given simplex whose subtrees generate its cofaces.\n\n\ncofaces\nReturns the p-cofaces of a given simplex.\n\n\ncollapse\nPerforms an elementary collapse on two given simplices.\n\n\ndegree\nComputes the degree of select vertices in the trie.\n\n\nexpand\nPerforms a k-expansion of the complex.\n\n\nfaces\nWrapper for simplices function.\n\n\nfind\nFinds whether simplices exist in Simplex Tree.\n\n\ninsert\nInserts simplices into the Simplex Tree.\n\n\nlink\nReturns all simplices in the link of a given simplex.\n\n\nmaximal\nReturns the maximal simplices in the complex.\n\n\nremove\nRemoves simplices into the Simplex Tree.\n\n\nsimplices\nReturns the p-simplices in the complex.\n\n\nskeleton\nReturns the simplices in the p-skeleton of the complex.\n\n\ntraverse\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered.\n\n\nvertex_collapse\nMaps a pair of vertices into a single vertex.\n\n\n\n\n\nSimplexTree.SimplexTree.adjacent(self, simplices)\nChecks for adjacencies between simplices.\n\n\n\nSimplexTree.SimplexTree.card(self, p=None)\nReturns the cardinality of various skeleta of the complex.\n\n\n\nSimplexTree.SimplexTree.coface_roots(self, sigma=[])\nReturns the simplex ‘roots’ of a given simplex whose subtrees generate its cofaces.\n\n\n\nSimplexTree.SimplexTree.cofaces(self, sigma=[])\nReturns the p-cofaces of a given simplex.\n\n\np : required\n\ncoface dimension to restrict to\n\nsigma : optional (default=[])\n\nthe simplex to obtain cofaces of\n\n\n\n\nlist :  list[Collection], \n\nthe p-cofaces of sigma\n\n\n\n\n\nSimplexTree.SimplexTree.collapse(self, tau, sigma)\nPerforms an elementary collapse on two given simplices.\nChecks whether its possible to collapse \\sigma through \\tau, and if so, both simplices are removed. A simplex \\sigma is said to be collapsible through one of its faces \\tau if \\sigma is the only coface of \\tau (excluding \\tau itself).\n\n\nsigma : required\n\nmaximal simplex to collapse\n\ntau : required\n\nface of sigma to collapse\n\n\n\n\nbool : None,\n\nwhether the pair was collapsed\n\n\n\n\nfrom splex import SimplexTree st = SimplexTree([[0,1,2]]) print(st)\nst.collapse([1,2], [0,1,2])\nprint(st)\n\n\n\n\nSimplexTree.SimplexTree.degree(self, vertices=None)\nComputes the degree of select vertices in the trie.\n\n\nvertices :  numpy.typing.ArrayLike, optional (default=None)\n\nRetrieves vertex degrees If no vertices are specified, all degrees are computed. Non-existing vertices by default have degree 0.\n\n\n\n\nlist :  Union[numpy.typing.ArrayLike, int], \n\ndegree of each vertex id given in ‘vertices’\n\n\n\n\n\nSimplexTree.SimplexTree.expand(self, k)\nPerforms a k-expansion of the complex.\nThis function is particularly useful for expanding clique complexes beyond their 1-skeleton.\n\n\nk : required\n\nmaximum dimension to expand to.\n\n\n\n\nfrom simplextree import SimplexTree from itertools import combinations st = SimplexTree(combinations(range(8), 2)) print(st)\nst.expand(k=2) print(st)\n\n\n\n\nSimplexTree.SimplexTree.faces(self, p=None, sigma=[], **kwargs)\nWrapper for simplices function.\n\n\n\nSimplexTree.SimplexTree.find(self, simplices)\nFinds whether simplices exist in Simplex Tree.\n\n\nsimplices :  Iterable[Collection], required\n\nIterable of simplices to insert (each of which are SimplexLike)\n\n\n\n\n**** :\n\nfound (ndarray) : boolean array indicating whether each simplex was found in the complex\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then the p-simplex to find is given by each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then searched for in the tree. \n\n\n\n\n\n\nSimplexTree.SimplexTree.insert(self, simplices)\nInserts simplices into the Simplex Tree.\nBy definition, inserting a simplex also inserts all of its faces. If the simplex already exists in the complex, the tree is not modified.\n\n\nsimplices :  Iterable[Collection], required\n\nIterable of simplices to insert (each of which are SimplexLike)\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is inserted along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then inserted into the tree. \n\n\n\n\n\n\nSimplexTree.SimplexTree.link(self, sigma=[])\nReturns all simplices in the link of a given simplex.\n\n\n\nSimplexTree.SimplexTree.maximal(self)\nReturns the maximal simplices in the complex.\n\n\n\nSimplexTree.SimplexTree.remove(self, simplices)\nRemoves simplices into the Simplex Tree.\nBy definition, removing a face also removes all of its cofaces. If the simplex does not exist in the complex, the tree is not modified.\n\n\nsimplices :  Iterable[Collection], required\n\nIterable of simplices to insert (each of which are SimplexLike).\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is removed along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then removed from the tree. \n\n\n\n\n\nst = SimplexTree([range(3)]) print(st) st.remove([[0,1]]) print(st)\n\n\n\n\nSimplexTree.SimplexTree.simplices(self, p=None)\nReturns the p-simplices in the complex.\n\n\n\nSimplexTree.SimplexTree.skeleton(self, p=None, sigma=[])\nReturns the simplices in the p-skeleton of the complex.\n\n\n\nSimplexTree.SimplexTree.traverse(self, order='preorder', f=print, sigma=[], p=0)\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered.\n\n\nUNHANDLED ADMONITION\nTo select one of these options, set order to one of [“bfs”, “levelorder”, “dfs”, “preorder”]\n\n\n\norder :  str, optional (default=‘preorder’)\n\nthe type of traversal of the simplex tree to execute.\n\nf :  Callable, optional (default=print)\n\na function to evaluate on every simplex in the traversal. Defaults to print.\n\nsigma :  Collection, optional (default=[])\n\nsimplex to start the traversal at, where applicable. Defaults to the root node (empty set).\n\np :  int, optional (default=0)\n\ndimension of simplices to restrict to, where applicable. Defaults to 0.\n\n\n\n\n\nSimplexTree.SimplexTree.vertex_collapse(self, u, v, w)\nMaps a pair of vertices into a single vertex.\n\n\nu :  int, required\n\nthe first vertex in the free pair.\n\nv :  int, required\n\nthe second vertex in the free pair.\n\nw :  int, required\n\nthe target vertex to collapse to."
  },
  {
    "objectID": "reference/SimplexTree.html#classes",
    "href": "reference/SimplexTree.html#classes",
    "title": "SimplexTree",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nSimplexTree\nSimplexTree provides lightweight wrapper around a Simplex Tree data structure: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex.\n\n\n\n\n\nSimplexTree.SimplexTree(self, simplices=None)\nSimplexTree provides lightweight wrapper around a Simplex Tree data structure: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex. This class exposes a native extension module wrapping a simplex tree implemented with modern C++.\nThe Simplex Tree was originally introduced in the paper &gt; Boissonnat, Jean-Daniel, and Clément Maria. “The simplex tree: An efficient data structure for general simplicial complexes.” Algorithmica 70.3 (2014): 406-427.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nn_simplices\nndarray\nnumber of simplices\n\n\ndimension\nint\nmaximal dimension of the complex\n\n\nid_policy\nstr\npolicy for generating new vertex ids\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nvertices\nndarray\nvertices of the complex\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadjacent\nChecks for adjacencies between simplices.\n\n\ncard\nReturns the cardinality of various skeleta of the complex.\n\n\ncoface_roots\nReturns the simplex ‘roots’ of a given simplex whose subtrees generate its cofaces.\n\n\ncofaces\nReturns the p-cofaces of a given simplex.\n\n\ncollapse\nPerforms an elementary collapse on two given simplices.\n\n\ndegree\nComputes the degree of select vertices in the trie.\n\n\nexpand\nPerforms a k-expansion of the complex.\n\n\nfaces\nWrapper for simplices function.\n\n\nfind\nFinds whether simplices exist in Simplex Tree.\n\n\ninsert\nInserts simplices into the Simplex Tree.\n\n\nlink\nReturns all simplices in the link of a given simplex.\n\n\nmaximal\nReturns the maximal simplices in the complex.\n\n\nremove\nRemoves simplices into the Simplex Tree.\n\n\nsimplices\nReturns the p-simplices in the complex.\n\n\nskeleton\nReturns the simplices in the p-skeleton of the complex.\n\n\ntraverse\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered.\n\n\nvertex_collapse\nMaps a pair of vertices into a single vertex.\n\n\n\n\n\nSimplexTree.SimplexTree.adjacent(self, simplices)\nChecks for adjacencies between simplices.\n\n\n\nSimplexTree.SimplexTree.card(self, p=None)\nReturns the cardinality of various skeleta of the complex.\n\n\n\nSimplexTree.SimplexTree.coface_roots(self, sigma=[])\nReturns the simplex ‘roots’ of a given simplex whose subtrees generate its cofaces.\n\n\n\nSimplexTree.SimplexTree.cofaces(self, sigma=[])\nReturns the p-cofaces of a given simplex.\n\n\np : required\n\ncoface dimension to restrict to\n\nsigma : optional (default=[])\n\nthe simplex to obtain cofaces of\n\n\n\n\nlist :  list[Collection], \n\nthe p-cofaces of sigma\n\n\n\n\n\nSimplexTree.SimplexTree.collapse(self, tau, sigma)\nPerforms an elementary collapse on two given simplices.\nChecks whether its possible to collapse \\sigma through \\tau, and if so, both simplices are removed. A simplex \\sigma is said to be collapsible through one of its faces \\tau if \\sigma is the only coface of \\tau (excluding \\tau itself).\n\n\nsigma : required\n\nmaximal simplex to collapse\n\ntau : required\n\nface of sigma to collapse\n\n\n\n\nbool : None,\n\nwhether the pair was collapsed\n\n\n\n\nfrom splex import SimplexTree st = SimplexTree([[0,1,2]]) print(st)\nst.collapse([1,2], [0,1,2])\nprint(st)\n\n\n\n\nSimplexTree.SimplexTree.degree(self, vertices=None)\nComputes the degree of select vertices in the trie.\n\n\nvertices :  numpy.typing.ArrayLike, optional (default=None)\n\nRetrieves vertex degrees If no vertices are specified, all degrees are computed. Non-existing vertices by default have degree 0.\n\n\n\n\nlist :  Union[numpy.typing.ArrayLike, int], \n\ndegree of each vertex id given in ‘vertices’\n\n\n\n\n\nSimplexTree.SimplexTree.expand(self, k)\nPerforms a k-expansion of the complex.\nThis function is particularly useful for expanding clique complexes beyond their 1-skeleton.\n\n\nk : required\n\nmaximum dimension to expand to.\n\n\n\n\nfrom simplextree import SimplexTree from itertools import combinations st = SimplexTree(combinations(range(8), 2)) print(st)\nst.expand(k=2) print(st)\n\n\n\n\nSimplexTree.SimplexTree.faces(self, p=None, sigma=[], **kwargs)\nWrapper for simplices function.\n\n\n\nSimplexTree.SimplexTree.find(self, simplices)\nFinds whether simplices exist in Simplex Tree.\n\n\nsimplices :  Iterable[Collection], required\n\nIterable of simplices to insert (each of which are SimplexLike)\n\n\n\n\n**** :\n\nfound (ndarray) : boolean array indicating whether each simplex was found in the complex\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then the p-simplex to find is given by each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then searched for in the tree. \n\n\n\n\n\n\nSimplexTree.SimplexTree.insert(self, simplices)\nInserts simplices into the Simplex Tree.\nBy definition, inserting a simplex also inserts all of its faces. If the simplex already exists in the complex, the tree is not modified.\n\n\nsimplices :  Iterable[Collection], required\n\nIterable of simplices to insert (each of which are SimplexLike)\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is inserted along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then inserted into the tree. \n\n\n\n\n\n\nSimplexTree.SimplexTree.link(self, sigma=[])\nReturns all simplices in the link of a given simplex.\n\n\n\nSimplexTree.SimplexTree.maximal(self)\nReturns the maximal simplices in the complex.\n\n\n\nSimplexTree.SimplexTree.remove(self, simplices)\nRemoves simplices into the Simplex Tree.\nBy definition, removing a face also removes all of its cofaces. If the simplex does not exist in the complex, the tree is not modified.\n\n\nsimplices :  Iterable[Collection], required\n\nIterable of simplices to insert (each of which are SimplexLike).\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is removed along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then removed from the tree. \n\n\n\n\n\nst = SimplexTree([range(3)]) print(st) st.remove([[0,1]]) print(st)\n\n\n\n\nSimplexTree.SimplexTree.simplices(self, p=None)\nReturns the p-simplices in the complex.\n\n\n\nSimplexTree.SimplexTree.skeleton(self, p=None, sigma=[])\nReturns the simplices in the p-skeleton of the complex.\n\n\n\nSimplexTree.SimplexTree.traverse(self, order='preorder', f=print, sigma=[], p=0)\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered.\n\n\nUNHANDLED ADMONITION\nTo select one of these options, set order to one of [“bfs”, “levelorder”, “dfs”, “preorder”]\n\n\n\norder :  str, optional (default=‘preorder’)\n\nthe type of traversal of the simplex tree to execute.\n\nf :  Callable, optional (default=print)\n\na function to evaluate on every simplex in the traversal. Defaults to print.\n\nsigma :  Collection, optional (default=[])\n\nsimplex to start the traversal at, where applicable. Defaults to the root node (empty set).\n\np :  int, optional (default=0)\n\ndimension of simplices to restrict to, where applicable. Defaults to 0.\n\n\n\n\n\nSimplexTree.SimplexTree.vertex_collapse(self, u, v, w)\nMaps a pair of vertices into a single vertex.\n\n\nu :  int, required\n\nthe first vertex in the free pair.\n\nv :  int, required\n\nthe second vertex in the free pair.\n\nw :  int, required\n\nthe target vertex to collapse to."
  },
  {
    "objectID": "pages/overview.html",
    "href": "pages/overview.html",
    "title": "Overview: Simplicial Complexes",
    "section": "",
    "text": "A simplicial complex S is a pair S = (V, \\Sigma) where V is a vertex set and \\Sigma a collection of simplices s \\in \\Sigma satisfying:\n\nIf v \\in V, then v \\in S\nIf \\tau \\subset \\sigma and \\sigma \\in S, then \\tau \\in S\n\nA simplicial complex is a natural generalization of a graph—any graph can also be represented by a simplicial complex (though the converse is not true!).\nLike graphs, there are many ways to represent simplicial complexes in memory. One such way is to use a simplex tree: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex. Here’s a picture (from the paper) of a simplicial 3-complex (left) and its corresponding Simplex Tree (right):\n\n\n\nsimplextree\n\n\nThe simplextree Python package exports an efficient class implementation of the simplex tree data structure. To construct the complex above with a simplex tree, it suffices to give the maximal simplices:\n\nfrom simplextree import SimplexTree\nst = SimplexTree([[1,2,3],[2,3,4,5],[6,7,9],[7,8],[10]]) # complex form the picture\nprint(st)\n\nSimplex Tree with (10, 12, 6, 1) (0, 1, 2, 3)-simplices\n\n\nTo look at the tree structure, use print_tree (see also: print_cousins)\n\nst.print_tree()\n\n1 (h = 2): .( 2 3 )..( 3 )\n2 (h = 3): .( 3 4 5 )..( 4 5 5 )...( 5 )\n3 (h = 2): .( 4 5 )..( 5 )\n4 (h = 1): .( 5 )\n5 (h = 0): \n6 (h = 2): .( 7 9 )..( 9 )\n7 (h = 1): .( 8 9 )\n8 (h = 0): \n9 (h = 0): \n10 (h = 0): \n\n\nThe supported operations include:"
  },
  {
    "objectID": "pages/overview.html#towards-interoperability",
    "href": "pages/overview.html#towards-interoperability",
    "title": "Overview: Simplicial Complexes",
    "section": "",
    "text": "splex promotes a common, pythonic interface for interacting with simplicial complexes that is independent of their internal representation.\nTo simplify usage, this interface incorporates the use of generics (inspired from R) and Protocol classes (to support duck-typing and structural subtyping).\nSee the design philosophy (todo) for more details."
  },
  {
    "objectID": "pages/overview.html#data-structures",
    "href": "pages/overview.html#data-structures",
    "title": "Overview: Simplicial Complexes",
    "section": "",
    "text": "Out-of-the-box, splex comes with three distinct data structures for representing simplicial complexes: as sets of simplices, as (structured) arrays of integers, and as integer-valued tries. See the complexes overview page for more details."
  },
  {
    "objectID": "pages/simplextree_ds.html",
    "href": "pages/simplextree_ds.html",
    "title": "Simplex Tree",
    "section": "",
    "text": "The simplex tree is…\n\n\n\nsimplextree\n\n\n\n\nCode\nimport numpy as np \nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()"
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "API Reference",
    "section": "",
    "text": "SimplexTree.SimplexTree\nSimplexTree provides lightweight wrapper around a Simplex Tree data structure: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex.\n\n\n\n\n\n\n\n\n\nUnionFind.UnionFind\nUnion Find data structure"
  },
  {
    "objectID": "reference/index.html#simplex-tree",
    "href": "reference/index.html#simplex-tree",
    "title": "API Reference",
    "section": "",
    "text": "SimplexTree.SimplexTree\nSimplexTree provides lightweight wrapper around a Simplex Tree data structure: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex."
  },
  {
    "objectID": "reference/index.html#simplex-tree-1",
    "href": "reference/index.html#simplex-tree-1",
    "title": "API Reference",
    "section": "",
    "text": "The Simplex Tree data structure for constructing and modifying abstract simplicial complexes\n\n\n\nSimplexTree"
  },
  {
    "objectID": "reference/index.html#union-find",
    "href": "reference/index.html#union-find",
    "title": "API Reference",
    "section": "",
    "text": "UnionFind.UnionFind\nUnion Find data structure"
  },
  {
    "objectID": "reference/UnionFind.html",
    "href": "reference/UnionFind.html",
    "title": "UnionFind",
    "section": "",
    "text": "UnionFind\n\n\n\n\n\nName\nDescription\n\n\n\n\nUnionFind\nUnion Find data structure\n\n\n\n\n\nUnionFind.UnionFind(n)\nUnion Find data structure"
  },
  {
    "objectID": "reference/UnionFind.html#classes",
    "href": "reference/UnionFind.html#classes",
    "title": "UnionFind",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nUnionFind\nUnion Find data structure\n\n\n\n\n\nUnionFind.UnionFind(n)\nUnion Find data structure"
  },
  {
    "objectID": "reference/UnionFind.UnionFind.html",
    "href": "reference/UnionFind.UnionFind.html",
    "title": "UnionFind.UnionFind",
    "section": "",
    "text": "UnionFind.UnionFind\nUnionFind.UnionFind(n)\nUnion Find data structure"
  },
  {
    "objectID": "reference/SimplexTree.SimplexTree.html",
    "href": "reference/SimplexTree.SimplexTree.html",
    "title": "SimplexTree.SimplexTree",
    "section": "",
    "text": "SimplexTree.SimplexTree(self, simplices=None)\nSimplexTree provides lightweight wrapper around a Simplex Tree data structure: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex. This class exposes a native extension module wrapping a simplex tree implemented with modern C++.\nThe Simplex Tree was originally introduced in the paper &gt; Boissonnat, Jean-Daniel, and Clément Maria. “The simplex tree: An efficient data structure for general simplicial complexes.” Algorithmica 70.3 (2014): 406-427.\nAttributes: n_simplices (ndarray): number of simplices dimension (int): maximal dimension of the complex id_policy (str): policy for generating new vertex ids\nAttributes: Properties: vertices (ndarray): vertices of the complex\n\n\n\n\n\nName\nDescription\n\n\n\n\nadjacent\nChecks for adjacencies between simplices.\n\n\ncard\nReturns the cardinality of various skeleta of the complex.\n\n\ncoface_roots\nReturns the simplex ‘roots’ of a given simplex whose subtrees generate its cofaces.\n\n\ncofaces\nReturns the p-cofaces of a given simplex.\n\n\ncollapse\nPerforms an elementary collapse on two given simplices.\n\n\ndegree\nComputes the degree of select vertices in the trie.\n\n\nexpand\nPerforms a k-expansion of the complex.\n\n\nfaces\nWrapper for simplices function.\n\n\nfind\nFinds whether simplices exist in Simplex Tree.\n\n\ninsert\nInserts simplices into the Simplex Tree.\n\n\nlink\nReturns all simplices in the link of a given simplex.\n\n\nmaximal\nReturns the maximal simplices in the complex.\n\n\nremove\nRemoves simplices into the Simplex Tree.\n\n\nsimplices\nReturns the p-simplices in the complex.\n\n\nskeleton\nReturns the simplices in the p-skeleton of the complex.\n\n\ntraverse\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered.\n\n\nvertex_collapse\nMaps a pair of vertices into a single vertex.\n\n\n\n\n\nSimplexTree.SimplexTree.adjacent(self, simplices)\nChecks for adjacencies between simplices.\n\n\n\nSimplexTree.SimplexTree.card(self, p=None)\nReturns the cardinality of various skeleta of the complex.\n\n\n\nSimplexTree.SimplexTree.coface_roots(self, sigma=\\[\\])\nReturns the simplex ‘roots’ of a given simplex whose subtrees generate its cofaces.\n\n\n\nSimplexTree.SimplexTree.cofaces(self, sigma=\\[\\])\nReturns the p-cofaces of a given simplex.\nParameters: p : coface dimension to restrict to sigma : the simplex to obtain cofaces of\nReturns: list: the p-cofaces of sigma\n\n\n\nSimplexTree.SimplexTree.collapse(self, tau, sigma)\nPerforms an elementary collapse on two given simplices.\nChecks whether its possible to collapse \\sigma through \\tau, and if so, both simplices are removed. A simplex \\sigma is said to be collapsible through one of its faces \\tau if \\sigma is the only coface of \\tau (excluding \\tau itself).\nParameters: sigma : maximal simplex to collapse tau : face of sigma to collapse\nReturns: bool: whether the pair was collapsed\nExamples:\n    from splex import SimplexTree \n    st = SimplexTree([[0,1,2]])\n    print(st)\n\n    st.collapse([1,2], [0,1,2])\n\n    print(st)\n\n\n\nSimplexTree.SimplexTree.degree(self, vertices=None)\nComputes the degree of select vertices in the trie.\nParameters: vertices (ArrayLike): Retrieves vertex degrees If no vertices are specified, all degrees are computed. Non-existing vertices by default have degree 0.\nReturns: list: degree of each vertex id given in ‘vertices’\n\n\n\nSimplexTree.SimplexTree.expand(self, k)\nPerforms a k-expansion of the complex.\nThis function is particularly useful for expanding clique complexes beyond their 1-skeleton.\nParameters: k : maximum dimension to expand to.\nExamples:\n    from simplextree import SimplexTree \n    from itertools import combinations \n    st = SimplexTree(combinations(range(8), 2))\n    print(st)\n    \n    st.expand(k=2)\n    print(st)\n\n\n\nSimplexTree.SimplexTree.faces(self, p=None, sigma=\\[\\], **kwargs)\nWrapper for simplices function.\n\n\n\nSimplexTree.SimplexTree.find(self, simplices)\nFinds whether simplices exist in Simplex Tree.\nParameters: simplices: Iterable of simplices to insert (each of which are SimplexLike)\nReturns: found (ndarray) : boolean array indicating whether each simplex was found in the complex\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then the p-simplex to find is given by each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then searched for in the tree. \n\n\n\n\n\nSimplexTree.SimplexTree.insert(self, simplices)\nInserts simplices into the Simplex Tree.\nBy definition, inserting a simplex also inserts all of its faces. If the simplex already exists in the complex, the tree is not modified.\nParameters: simplices: Iterable of simplices to insert (each of which are SimplexLike)\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is inserted along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then inserted into the tree. \n\n\n\n\n\nSimplexTree.SimplexTree.link(self, sigma=\\[\\])\nReturns all simplices in the link of a given simplex.\n\n\n\nSimplexTree.SimplexTree.maximal(self)\nReturns the maximal simplices in the complex.\n\n\n\nSimplexTree.SimplexTree.remove(self, simplices)\nRemoves simplices into the Simplex Tree.\nBy definition, removing a face also removes all of its cofaces. If the simplex does not exist in the complex, the tree is not modified.\nParameters: simplices: Iterable of simplices to insert (each of which are SimplexLike).\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is removed along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then removed from the tree. \n\n\nExamples: st = SimplexTree([range(3)]) print(st) st.remove([[0,1]]) print(st)\n\n\n\nSimplexTree.SimplexTree.simplices(self, p=None)\nReturns the p-simplices in the complex.\n\n\n\nSimplexTree.SimplexTree.skeleton(self, p=None, sigma=\\[\\])\nReturns the simplices in the p-skeleton of the complex.\n\n\n\nSimplexTree.SimplexTree.traverse(self, order='preorder', f=print, sigma=\\[\\], p=0)\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered.\nSupported traversals: - breadth-first / level order (“bfs”, “levelorder”) - depth-first / prefix (“dfs”, “preorder”) - faces - cofaces - coface roots (“coface_roots”) - p-skeleton - p-simplices - maximal simplices (“maximal”) - link To select one of these options, set order to one of [“bfs”, “levelorder”, “dfs”, “preorder”]\nParameters: order: the type of traversal of the simplex tree to execute. f: a function to evaluate on every simplex in the traversal. Defaults to print. sigma: simplex to start the traversal at, where applicable. Defaults to the root node (empty set). p: dimension of simplices to restrict to, where applicable. Defaults to 0.\n\n\n\nSimplexTree.SimplexTree.vertex_collapse(self, u, v, w)\nMaps a pair of vertices into a single vertex.\nParameters: u (int): the first vertex in the free pair. v (int): the second vertex in the free pair. w (int): the target vertex to collapse to."
  },
  {
    "objectID": "reference/SimplexTree.SimplexTree.html#methods",
    "href": "reference/SimplexTree.SimplexTree.html#methods",
    "title": "SimplexTree.SimplexTree",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nadjacent\nChecks for adjacencies between simplices.\n\n\ncard\nReturns the cardinality of various skeleta of the complex.\n\n\ncoface_roots\nReturns the simplex ‘roots’ of a given simplex whose subtrees generate its cofaces.\n\n\ncofaces\nReturns the p-cofaces of a given simplex.\n\n\ncollapse\nPerforms an elementary collapse on two given simplices.\n\n\ndegree\nComputes the degree of select vertices in the trie.\n\n\nexpand\nPerforms a k-expansion of the complex.\n\n\nfaces\nWrapper for simplices function.\n\n\nfind\nFinds whether simplices exist in Simplex Tree.\n\n\ninsert\nInserts simplices into the Simplex Tree.\n\n\nlink\nReturns all simplices in the link of a given simplex.\n\n\nmaximal\nReturns the maximal simplices in the complex.\n\n\nremove\nRemoves simplices into the Simplex Tree.\n\n\nsimplices\nReturns the p-simplices in the complex.\n\n\nskeleton\nReturns the simplices in the p-skeleton of the complex.\n\n\ntraverse\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered.\n\n\nvertex_collapse\nMaps a pair of vertices into a single vertex.\n\n\n\n\n\nSimplexTree.SimplexTree.adjacent(self, simplices)\nChecks for adjacencies between simplices.\n\n\n\nSimplexTree.SimplexTree.card(self, p=None)\nReturns the cardinality of various skeleta of the complex.\n\n\n\nSimplexTree.SimplexTree.coface_roots(self, sigma=\\[\\])\nReturns the simplex ‘roots’ of a given simplex whose subtrees generate its cofaces.\n\n\n\nSimplexTree.SimplexTree.cofaces(self, sigma=\\[\\])\nReturns the p-cofaces of a given simplex.\nParameters: p : coface dimension to restrict to sigma : the simplex to obtain cofaces of\nReturns: list: the p-cofaces of sigma\n\n\n\nSimplexTree.SimplexTree.collapse(self, tau, sigma)\nPerforms an elementary collapse on two given simplices.\nChecks whether its possible to collapse \\sigma through \\tau, and if so, both simplices are removed. A simplex \\sigma is said to be collapsible through one of its faces \\tau if \\sigma is the only coface of \\tau (excluding \\tau itself).\nParameters: sigma : maximal simplex to collapse tau : face of sigma to collapse\nReturns: bool: whether the pair was collapsed\nExamples:\n    from splex import SimplexTree \n    st = SimplexTree([[0,1,2]])\n    print(st)\n\n    st.collapse([1,2], [0,1,2])\n\n    print(st)\n\n\n\nSimplexTree.SimplexTree.degree(self, vertices=None)\nComputes the degree of select vertices in the trie.\nParameters: vertices (ArrayLike): Retrieves vertex degrees If no vertices are specified, all degrees are computed. Non-existing vertices by default have degree 0.\nReturns: list: degree of each vertex id given in ‘vertices’\n\n\n\nSimplexTree.SimplexTree.expand(self, k)\nPerforms a k-expansion of the complex.\nThis function is particularly useful for expanding clique complexes beyond their 1-skeleton.\nParameters: k : maximum dimension to expand to.\nExamples:\n    from simplextree import SimplexTree \n    from itertools import combinations \n    st = SimplexTree(combinations(range(8), 2))\n    print(st)\n    \n    st.expand(k=2)\n    print(st)\n\n\n\nSimplexTree.SimplexTree.faces(self, p=None, sigma=\\[\\], **kwargs)\nWrapper for simplices function.\n\n\n\nSimplexTree.SimplexTree.find(self, simplices)\nFinds whether simplices exist in Simplex Tree.\nParameters: simplices: Iterable of simplices to insert (each of which are SimplexLike)\nReturns: found (ndarray) : boolean array indicating whether each simplex was found in the complex\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then the p-simplex to find is given by each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then searched for in the tree. \n\n\n\n\n\nSimplexTree.SimplexTree.insert(self, simplices)\nInserts simplices into the Simplex Tree.\nBy definition, inserting a simplex also inserts all of its faces. If the simplex already exists in the complex, the tree is not modified.\nParameters: simplices: Iterable of simplices to insert (each of which are SimplexLike)\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is inserted along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then inserted into the tree. \n\n\n\n\n\nSimplexTree.SimplexTree.link(self, sigma=\\[\\])\nReturns all simplices in the link of a given simplex.\n\n\n\nSimplexTree.SimplexTree.maximal(self)\nReturns the maximal simplices in the complex.\n\n\n\nSimplexTree.SimplexTree.remove(self, simplices)\nRemoves simplices into the Simplex Tree.\nBy definition, removing a face also removes all of its cofaces. If the simplex does not exist in the complex, the tree is not modified.\nParameters: simplices: Iterable of simplices to insert (each of which are SimplexLike).\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is removed along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then removed from the tree. \n\n\nExamples: st = SimplexTree([range(3)]) print(st) st.remove([[0,1]]) print(st)\n\n\n\nSimplexTree.SimplexTree.simplices(self, p=None)\nReturns the p-simplices in the complex.\n\n\n\nSimplexTree.SimplexTree.skeleton(self, p=None, sigma=\\[\\])\nReturns the simplices in the p-skeleton of the complex.\n\n\n\nSimplexTree.SimplexTree.traverse(self, order='preorder', f=print, sigma=\\[\\], p=0)\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered.\nSupported traversals: - breadth-first / level order (“bfs”, “levelorder”) - depth-first / prefix (“dfs”, “preorder”) - faces - cofaces - coface roots (“coface_roots”) - p-skeleton - p-simplices - maximal simplices (“maximal”) - link To select one of these options, set order to one of [“bfs”, “levelorder”, “dfs”, “preorder”]\nParameters: order: the type of traversal of the simplex tree to execute. f: a function to evaluate on every simplex in the traversal. Defaults to print. sigma: simplex to start the traversal at, where applicable. Defaults to the root node (empty set). p: dimension of simplices to restrict to, where applicable. Defaults to 0.\n\n\n\nSimplexTree.SimplexTree.vertex_collapse(self, u, v, w)\nMaps a pair of vertices into a single vertex.\nParameters: u (int): the first vertex in the free pair. v (int): the second vertex in the free pair. w (int): the target vertex to collapse to."
  },
  {
    "objectID": "pages/reference/UnionFind.UnionFind.html",
    "href": "pages/reference/UnionFind.UnionFind.html",
    "title": "UnionFind.UnionFind",
    "section": "",
    "text": "UnionFind.UnionFind\nUnionFind.UnionFind(n)\nUnion Find data structure"
  },
  {
    "objectID": "pages/reference/SimplexTree.SimplexTree.html",
    "href": "pages/reference/SimplexTree.SimplexTree.html",
    "title": "SimplexTree.SimplexTree",
    "section": "",
    "text": "SimplexTree.SimplexTree(self, simplices=None)\nSimplexTree provides lightweight wrapper around a Simplex Tree data structure: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex. This class exposes a native extension module wrapping a simplex tree implemented with modern C++.\nThe Simplex Tree was originally introduced in the paper &gt; Boissonnat, Jean-Daniel, and Clément Maria. “The simplex tree: An efficient data structure for general simplicial complexes.” Algorithmica 70.3 (2014): 406-427.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nn_simplices\nndarray\nnumber of simplices\n\n\ndimension\nint\nmaximal dimension of the complex\n\n\nid_policy\nstr\npolicy for generating new vertex ids\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nvertices\nndarray\nvertices of the complex\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadjacent\nChecks for adjacencies between simplices.\n\n\ncard\nReturns the cardinality of various skeleta of the complex.\n\n\ncoface_roots\nReturns the simplex ‘roots’ of a given simplex whose subtrees generate its cofaces.\n\n\ncofaces\nReturns the p-cofaces of a given simplex.\n\n\ncollapse\nPerforms an elementary collapse on two given simplices.\n\n\ndegree\nComputes the degree of select vertices in the trie.\n\n\nexpand\nPerforms a k-expansion of the complex.\n\n\nfaces\nWrapper for simplices function.\n\n\nfind\nFinds whether simplices exist in Simplex Tree.\n\n\ninsert\nInserts simplices into the Simplex Tree.\n\n\nlink\nReturns all simplices in the link of a given simplex.\n\n\nmaximal\nReturns the maximal simplices in the complex.\n\n\nremove\nRemoves simplices into the Simplex Tree.\n\n\nsimplices\nReturns the p-simplices in the complex.\n\n\nskeleton\nReturns the simplices in the p-skeleton of the complex.\n\n\ntraverse\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered.\n\n\nvertex_collapse\nMaps a pair of vertices into a single vertex.\n\n\n\n\n\nSimplexTree.SimplexTree.adjacent(self, simplices)\nChecks for adjacencies between simplices.\n\n\n\nSimplexTree.SimplexTree.card(self, p=None)\nReturns the cardinality of various skeleta of the complex.\n\n\n\nSimplexTree.SimplexTree.coface_roots(self, sigma=\\[\\])\nReturns the simplex ‘roots’ of a given simplex whose subtrees generate its cofaces.\n\n\n\nSimplexTree.SimplexTree.cofaces(self, sigma=\\[\\])\nReturns the p-cofaces of a given simplex.\n\n\np : required\n\ncoface dimension to restrict to\n\nsigma : optional (default=[])\n\nthe simplex to obtain cofaces of\n\n\n\n\nlist :  list[Collection], \n\nthe p-cofaces of sigma\n\n\n\n\n\nSimplexTree.SimplexTree.collapse(self, tau, sigma)\nPerforms an elementary collapse on two given simplices.\nChecks whether its possible to collapse \\sigma through \\tau, and if so, both simplices are removed. A simplex \\sigma is said to be collapsible through one of its faces \\tau if \\sigma is the only coface of \\tau (excluding \\tau itself).\n\n\nsigma : required\n\nmaximal simplex to collapse\n\ntau : required\n\nface of sigma to collapse\n\n\n\n\nbool : None,\n\nwhether the pair was collapsed\n\n\n\n\nfrom splex import SimplexTree st = SimplexTree([[0,1,2]]) print(st)\nst.collapse([1,2], [0,1,2])\nprint(st)\n\n\n\n\nSimplexTree.SimplexTree.degree(self, vertices=None)\nComputes the degree of select vertices in the trie.\n\n\nvertices :  numpy.typing.ArrayLike, optional (default=None)\n\nRetrieves vertex degrees If no vertices are specified, all degrees are computed. Non-existing vertices by default have degree 0.\n\n\n\n\nlist :  Union[numpy.typing.ArrayLike, int], \n\ndegree of each vertex id given in ‘vertices’\n\n\n\n\n\nSimplexTree.SimplexTree.expand(self, k)\nPerforms a k-expansion of the complex.\nThis function is particularly useful for expanding clique complexes beyond their 1-skeleton.\n\n\nk : required\n\nmaximum dimension to expand to.\n\n\n\n\nfrom simplextree import SimplexTree from itertools import combinations st = SimplexTree(combinations(range(8), 2)) print(st)\nst.expand(k=2) print(st)\n\n\n\n\nSimplexTree.SimplexTree.faces(self, p=None, sigma=\\[\\], **kwargs)\nWrapper for simplices function.\n\n\n\nSimplexTree.SimplexTree.find(self, simplices)\nFinds whether simplices exist in Simplex Tree.\n\n\nsimplices :  Iterable[Collection], required\n\nIterable of simplices to insert (each of which are SimplexLike)\n\n\n\n\n**** :\n\nfound (ndarray) : boolean array indicating whether each simplex was found in the complex\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then the p-simplex to find is given by each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then searched for in the tree. \n\n\n\n\n\n\nSimplexTree.SimplexTree.insert(self, simplices)\nInserts simplices into the Simplex Tree.\nBy definition, inserting a simplex also inserts all of its faces. If the simplex already exists in the complex, the tree is not modified.\n\n\nsimplices :  Iterable[Collection], required\n\nIterable of simplices to insert (each of which are SimplexLike)\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is inserted along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then inserted into the tree. \n\n\n\n\n\n\nSimplexTree.SimplexTree.link(self, sigma=\\[\\])\nReturns all simplices in the link of a given simplex.\n\n\n\nSimplexTree.SimplexTree.maximal(self)\nReturns the maximal simplices in the complex.\n\n\n\nSimplexTree.SimplexTree.remove(self, simplices)\nRemoves simplices into the Simplex Tree.\nBy definition, removing a face also removes all of its cofaces. If the simplex does not exist in the complex, the tree is not modified.\n\n\nsimplices :  Iterable[Collection], required\n\nIterable of simplices to insert (each of which are SimplexLike).\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is removed along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then removed from the tree. \n\n\n\n\n\nst = SimplexTree([range(3)]) print(st) st.remove([[0,1]]) print(st)\n\n\n\n\nSimplexTree.SimplexTree.simplices(self, p=None)\nReturns the p-simplices in the complex.\n\n\n\nSimplexTree.SimplexTree.skeleton(self, p=None, sigma=\\[\\])\nReturns the simplices in the p-skeleton of the complex.\n\n\n\nSimplexTree.SimplexTree.traverse(self, order='preorder', f=print, sigma=\\[\\], p=0)\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered.\n\n\nUNHANDLED ADMONITION\nTo select one of these options, set order to one of [“bfs”, “levelorder”, “dfs”, “preorder”]\n\n\n\norder :  str, optional (default=‘preorder’)\n\nthe type of traversal of the simplex tree to execute.\n\nf :  Callable, optional (default=print)\n\na function to evaluate on every simplex in the traversal. Defaults to print.\n\nsigma :  Collection, optional (default=[])\n\nsimplex to start the traversal at, where applicable. Defaults to the root node (empty set).\n\np :  int, optional (default=0)\n\ndimension of simplices to restrict to, where applicable. Defaults to 0.\n\n\n\n\n\nSimplexTree.SimplexTree.vertex_collapse(self, u, v, w)\nMaps a pair of vertices into a single vertex.\n\n\nu :  int, required\n\nthe first vertex in the free pair.\n\nv :  int, required\n\nthe second vertex in the free pair.\n\nw :  int, required\n\nthe target vertex to collapse to."
  },
  {
    "objectID": "pages/reference/SimplexTree.SimplexTree.html#methods",
    "href": "pages/reference/SimplexTree.SimplexTree.html#methods",
    "title": "SimplexTree.SimplexTree",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nadjacent\nChecks for adjacencies between simplices.\n\n\ncard\nReturns the cardinality of various skeleta of the complex.\n\n\ncoface_roots\nReturns the simplex ‘roots’ of a given simplex whose subtrees generate its cofaces.\n\n\ncofaces\nReturns the p-cofaces of a given simplex.\n\n\ncollapse\nPerforms an elementary collapse on two given simplices.\n\n\ndegree\nComputes the degree of select vertices in the trie.\n\n\nexpand\nPerforms a k-expansion of the complex.\n\n\nfaces\nWrapper for simplices function.\n\n\nfind\nFinds whether simplices exist in Simplex Tree.\n\n\ninsert\nInserts simplices into the Simplex Tree.\n\n\nlink\nReturns all simplices in the link of a given simplex.\n\n\nmaximal\nReturns the maximal simplices in the complex.\n\n\nremove\nRemoves simplices into the Simplex Tree.\n\n\nsimplices\nReturns the p-simplices in the complex.\n\n\nskeleton\nReturns the simplices in the p-skeleton of the complex.\n\n\ntraverse\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered.\n\n\nvertex_collapse\nMaps a pair of vertices into a single vertex.\n\n\n\n\n\nSimplexTree.SimplexTree.adjacent(self, simplices)\nChecks for adjacencies between simplices.\n\n\n\nSimplexTree.SimplexTree.card(self, p=None)\nReturns the cardinality of various skeleta of the complex.\n\n\n\nSimplexTree.SimplexTree.coface_roots(self, sigma=\\[\\])\nReturns the simplex ‘roots’ of a given simplex whose subtrees generate its cofaces.\n\n\n\nSimplexTree.SimplexTree.cofaces(self, sigma=\\[\\])\nReturns the p-cofaces of a given simplex.\n\n\np : required\n\ncoface dimension to restrict to\n\nsigma : optional (default=[])\n\nthe simplex to obtain cofaces of\n\n\n\n\nlist :  list[Collection], \n\nthe p-cofaces of sigma\n\n\n\n\n\nSimplexTree.SimplexTree.collapse(self, tau, sigma)\nPerforms an elementary collapse on two given simplices.\nChecks whether its possible to collapse \\sigma through \\tau, and if so, both simplices are removed. A simplex \\sigma is said to be collapsible through one of its faces \\tau if \\sigma is the only coface of \\tau (excluding \\tau itself).\n\n\nsigma : required\n\nmaximal simplex to collapse\n\ntau : required\n\nface of sigma to collapse\n\n\n\n\nbool : None,\n\nwhether the pair was collapsed\n\n\n\n\nfrom splex import SimplexTree st = SimplexTree([[0,1,2]]) print(st)\nst.collapse([1,2], [0,1,2])\nprint(st)\n\n\n\n\nSimplexTree.SimplexTree.degree(self, vertices=None)\nComputes the degree of select vertices in the trie.\n\n\nvertices :  numpy.typing.ArrayLike, optional (default=None)\n\nRetrieves vertex degrees If no vertices are specified, all degrees are computed. Non-existing vertices by default have degree 0.\n\n\n\n\nlist :  Union[numpy.typing.ArrayLike, int], \n\ndegree of each vertex id given in ‘vertices’\n\n\n\n\n\nSimplexTree.SimplexTree.expand(self, k)\nPerforms a k-expansion of the complex.\nThis function is particularly useful for expanding clique complexes beyond their 1-skeleton.\n\n\nk : required\n\nmaximum dimension to expand to.\n\n\n\n\nfrom simplextree import SimplexTree from itertools import combinations st = SimplexTree(combinations(range(8), 2)) print(st)\nst.expand(k=2) print(st)\n\n\n\n\nSimplexTree.SimplexTree.faces(self, p=None, sigma=\\[\\], **kwargs)\nWrapper for simplices function.\n\n\n\nSimplexTree.SimplexTree.find(self, simplices)\nFinds whether simplices exist in Simplex Tree.\n\n\nsimplices :  Iterable[Collection], required\n\nIterable of simplices to insert (each of which are SimplexLike)\n\n\n\n\n**** :\n\nfound (ndarray) : boolean array indicating whether each simplex was found in the complex\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then the p-simplex to find is given by each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then searched for in the tree. \n\n\n\n\n\n\nSimplexTree.SimplexTree.insert(self, simplices)\nInserts simplices into the Simplex Tree.\nBy definition, inserting a simplex also inserts all of its faces. If the simplex already exists in the complex, the tree is not modified.\n\n\nsimplices :  Iterable[Collection], required\n\nIterable of simplices to insert (each of which are SimplexLike)\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is inserted along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then inserted into the tree. \n\n\n\n\n\n\nSimplexTree.SimplexTree.link(self, sigma=\\[\\])\nReturns all simplices in the link of a given simplex.\n\n\n\nSimplexTree.SimplexTree.maximal(self)\nReturns the maximal simplices in the complex.\n\n\n\nSimplexTree.SimplexTree.remove(self, simplices)\nRemoves simplices into the Simplex Tree.\nBy definition, removing a face also removes all of its cofaces. If the simplex does not exist in the complex, the tree is not modified.\n\n\nsimplices :  Iterable[Collection], required\n\nIterable of simplices to insert (each of which are SimplexLike).\n\n\n\n\n\n\n\nNote\n\n\n\n    If the iterable is an 2-dim np.ndarray, then a p-simplex is removed along each contiguous p+1 stride.\n    Otherwise, each element of the iterable to casted to a Simplex and then removed from the tree. \n\n\n\n\n\nst = SimplexTree([range(3)]) print(st) st.remove([[0,1]]) print(st)\n\n\n\n\nSimplexTree.SimplexTree.simplices(self, p=None)\nReturns the p-simplices in the complex.\n\n\n\nSimplexTree.SimplexTree.skeleton(self, p=None, sigma=\\[\\])\nReturns the simplices in the p-skeleton of the complex.\n\n\n\nSimplexTree.SimplexTree.traverse(self, order='preorder', f=print, sigma=\\[\\], p=0)\nTraverses the simplex tree in the specified order, calling ‘f’ on each simplex encountered.\n\n\nUNHANDLED ADMONITION\nTo select one of these options, set order to one of [“bfs”, “levelorder”, “dfs”, “preorder”]\n\n\n\norder :  str, optional (default=‘preorder’)\n\nthe type of traversal of the simplex tree to execute.\n\nf :  Callable, optional (default=print)\n\na function to evaluate on every simplex in the traversal. Defaults to print.\n\nsigma :  Collection, optional (default=[])\n\nsimplex to start the traversal at, where applicable. Defaults to the root node (empty set).\n\np :  int, optional (default=0)\n\ndimension of simplices to restrict to, where applicable. Defaults to 0.\n\n\n\n\n\nSimplexTree.SimplexTree.vertex_collapse(self, u, v, w)\nMaps a pair of vertices into a single vertex.\n\n\nu :  int, required\n\nthe first vertex in the free pair.\n\nv :  int, required\n\nthe second vertex in the free pair.\n\nw :  int, required\n\nthe target vertex to collapse to."
  },
  {
    "objectID": "pages/reference/index.html",
    "href": "pages/reference/index.html",
    "title": "API Reference",
    "section": "",
    "text": "SimplexTree.SimplexTree\nSimplexTree provides lightweight wrapper around a Simplex Tree data structure: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex.\n\n\n\n\n\n\n\n\n\nUnionFind.UnionFind\nUnion Find data structure"
  },
  {
    "objectID": "pages/reference/index.html#simplex-tree",
    "href": "pages/reference/index.html#simplex-tree",
    "title": "API Reference",
    "section": "",
    "text": "SimplexTree.SimplexTree\nSimplexTree provides lightweight wrapper around a Simplex Tree data structure: an ordered, trie-like structure whose nodes are in bijection with the faces of the complex."
  },
  {
    "objectID": "pages/reference/index.html#union-find",
    "href": "pages/reference/index.html#union-find",
    "title": "API Reference",
    "section": "",
    "text": "UnionFind.UnionFind\nUnion Find data structure"
  },
  {
    "objectID": "pages/reference/SimplexTree.SimplexTree.html#attributes",
    "href": "pages/reference/SimplexTree.SimplexTree.html#attributes",
    "title": "SimplexTree.SimplexTree",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nn_simplices\nndarray\nnumber of simplices\n\n\ndimension\nint\nmaximal dimension of the complex\n\n\nid_policy\nstr\npolicy for generating new vertex ids"
  },
  {
    "objectID": "pages/reference/SimplexTree.SimplexTree.html#properties",
    "href": "pages/reference/SimplexTree.SimplexTree.html#properties",
    "title": "SimplexTree.SimplexTree",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nvertices\nndarray\nvertices of the complex"
  }
]