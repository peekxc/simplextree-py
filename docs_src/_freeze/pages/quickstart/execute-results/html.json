{
  "hash": "33cdd1f3a90a6c7ab1b48957e252f2ab",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nformat:\n  html:\n    code-fold: false\nexecute:\n  freeze: auto\n  enabled: true\ndraft: true\ntitle: Quick Start\n---\n\n\n\n\n\nYou can construct a `SimplexTree` by supplying simplices. Any collection of integer-valued `Iterable`'s will do, e.g. a list of lists: \n\n\n::: {#5651e2b7 .cell execution_count=1}\n``` {.python .cell-code lst-cap=\"The SimplexTree class provides light wrapper around the extension module\" code-summary=\"SimplexTree constructor\"}\nfrom simplextree import SimplexTree\nst = SimplexTree([[0,1,2], [0,1], [4,5]]) \nprint(st) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimplex Tree with (5, 4, 1) (0, 1, 2)-simplices\n```\n:::\n:::\n\n\nBatch insertion, removal, and membership queries are supported\n\n::: {#28a591e0 .cell execution_count=2}\n``` {.python .cell-code code-summary=\"Batch operations\"}\nst.insert([[1,4], [1,5], [6]])\nprint(st)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimplex Tree with (6, 6, 1) (0, 1, 2)-simplices\n```\n:::\n:::\n\n\n::: {#9cf33c38 .cell execution_count=3}\n``` {.python .cell-code}\nst.remove([[6]])\nprint(st)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimplex Tree with (5, 6, 1) (0, 1, 2)-simplices\n```\n:::\n:::\n\n\n::: {#275ec288 .cell execution_count=4}\n``` {.python .cell-code}\nprint(st.find([[6], [0,1]]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[False  True]\n```\n:::\n:::\n\n\nCollections of simplices are returned as simple lists-of-lists:\n\n::: {#411c6814 .cell execution_count=5}\n``` {.python .cell-code code-summary=\"Complex collections\"}\nprint(st.simplices())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[(0,), (1,), (2,), (4,), (5,), (0, 1), (0, 2), (1, 2), (1, 4), (1, 5), (4, 5), (0, 1, 2)]\n```\n:::\n:::\n\n\nVarious parameters can be given to restrict a given subset to certain subsets or orders: \n\n::: {#f1c69ada .cell execution_count=6}\n``` {.python .cell-code}\nprint(st.simplices(p=1)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[(0, 1), (0, 2), (1, 2), (1, 4), (1, 5), (4, 5)]\n```\n:::\n:::\n\n\nFamiliar Pythonic [Collection semantics](https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes) are supported, including \\_\\_contains\\_\\_, \\_\\_iter\\_\\_ support, and \\_\\_len\\_\\_:\n\n::: {#67db3a7b .cell execution_count=7}\n``` {.python .cell-code}\nprint([0,1,2] in st)\nprint([len(simplex) for simplex in st])\nprint(len(st))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n[1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3]\n12\n```\n:::\n:::\n\n\nThe cofaces of any simplex can be listed with `cofaces`:\n\n::: {#1136a769 .cell execution_count=8}\n``` {.python .cell-code}\nprint(\"Cofaces([1]): \" + str(st.cofaces([1])))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCofaces([1]): [(1,), (1, 2), (1, 4), (1, 5), (0, 1), (0, 1, 2)]\n```\n:::\n:::\n\n\nThe maximal simplices can be listed with `maximal`:\n\n::: {#e03d069b .cell execution_count=9}\n``` {.python .cell-code}\nprint(\"Maximal: \" + str(st.maximal()))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMaximal: [(0, 1, 2), (1, 4), (1, 5), (4, 5)]\n```\n:::\n:::\n\n\nBasic properties are also available as attributes \n\n::: {#1b3ae4c4 .cell execution_count=10}\n``` {.python .cell-code}\nst.n_simplices, st.dimension, st.vertices, st.connected_components\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n(array([5, 6, 1], dtype=uint64), 2, [0, 1, 2, 4, 5], [1, 1, 1, 1, 1])\n```\n:::\n:::\n\n\nInteroperability with numpy is provided whenever possible\n\n::: {#0ba498f4 .cell execution_count=11}\n``` {.python .cell-code}\nimport numpy as np \nall(np.all(st.triangles == np.array(st.simplices(p=2)), axis=0))\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nTrue\n```\n:::\n:::\n\n\nOther complex-wide operations are supported, like $k$-expansions \n\n::: {#b0f35c21 .cell execution_count=12}\n``` {.python .cell-code}\nst.insert([[1,4]]) \nst.expand(2)       \nprint(st)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimplex Tree with (5, 6, 2) (0, 1, 2)-simplices\n```\n:::\n:::\n\n\nThe trie-structure can also be inspected on the python side with `print_tree`:\n\n::: {#35d32b3f .cell execution_count=13}\n``` {.python .cell-code}\nst.print_tree()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0 (h = 2): .( 1 2 )..( 2 )\n1 (h = 2): .( 2 4 5 )..( 5 )\n2 (h = 0): \n4 (h = 1): .( 5 )\n5 (h = 0): \n```\n:::\n:::\n\n\nYet another way is to _traverse_ the complex in a depth-first manner (prefix-order), printing every simplex as it appears in the traversal:\n\n::: {#6e54dcea .cell execution_count=14}\n``` {.python .cell-code}\nst.traverse(\"dfs\", f=print)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(0,)\n(0, 1)\n(0, 1, 2)\n(0, 2)\n(1,)\n(1, 2)\n(1, 4)\n(1, 4, 5)\n(1, 5)\n(2,)\n(4,)\n(4, 5)\n(5,)\n```\n:::\n:::\n\n\nSeveral traversal orderings are provided, e.g. breadth-first could be used as well (level-order):\n\n::: {#46622aca .cell execution_count=15}\n``` {.python .cell-code}\nst.traverse(\"bfs\", f=print)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(0,)\n(1,)\n(2,)\n(4,)\n(5,)\n(0, 1)\n(0, 2)\n(1, 2)\n(1, 4)\n(1, 5)\n(4, 5)\n(0, 1, 2)\n(1, 4, 5)\n```\n:::\n:::\n\n\nIn fact, most operations on the Simplex tree are actually _implemented_ using traversals. For example, \n\nst.traverse(\"maximal\", f=print)\n\n",
    "supporting": [
      "quickstart_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}